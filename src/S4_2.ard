\import Function ()
\import HLevel
\import Homotopy.Truncation
\import Paths

-- 4.2.1
\class Precategory (A : \Type) {
  | mor : A -> A -> \Set
  | ide (x : A) : mor x x
  | \infixr 8 o {x y z : A} : mor y z -> mor x y -> mor x z
  \property id-left {x y : A} (f : mor x y) : ide _ o f = f
  \property id-right {x y : A} (f : mor x y) : f o ide _ = f
  \property o-assoc {x y z w : A} (f : mor z w) (g : mor y z) (h : mor x y) : (f o g) o h = f o (g o h)
}
\func id {C : Precategory} {x : C} => ide x

-- 4.2.2
-- hPOV: the "size" issue disappears due to the infinite hierarchy of p-levels
\instance Precategory-Set : Precategory \Set
  | mor A B => A -> B
  | ide _ => Function.id
  | o => Function.o
  | id-left _ => idp
  | id-right _ => idp
  | o-assoc _ _ _ => idp

-- 4.2.3 is implicit in the definition

-- 4.2.4
\record Isomorphism {C : Precategory} (x y : C) (f : mor x y) {
  | f^-1 : mor y x
  \property inv-left : f^-1 o f = id
  \property inv-right : f o f^-1 = id
} \where {
  \func inv-unique {C : Precategory} {x y : C} {f : mor x y} (e : Isomorphism x y f) (e' : Isomorphism x y f) : e.f^-1 = e'.f^-1 =>
    f^-1                 ==< inv (C.id-left f^-1) >==
    id o f^-1            ==< pmap (`o f^-1) (inv (e'.inv-left)) >==
    (e'.f^-1 o f) o f^-1 ==< C.o-assoc _ _ _ >==
    e'.f^-1 o (f o f^-1) ==< pmap (e'.f^-1 o) (e.inv-right) >==
    e'.f^-1 o id         ==< C.id-right e'.f^-1 >==
    e'.f^-1 `qed
  \use \level levelProp {C : Precategory} {x y : C} (f : mor x y) (e e' : Isomorphism x y f) : e = e' =>
    \let p => inv-unique e e'
    \in path (\lam i => \new Isomorphism x y f {
      | f^-1 => p @ i
      | inv-left => (pathInProp (\lam j => p @ j o f = id) e.inv-left e'.inv-left) @ i
      | inv-right => (pathInProp (\lam j => f o p @ j = id) e.inv-right e'.inv-right) @ i
    } )
}
\func \infix 1 ~= {C : Precategory} (x y : C) : \Set => Isomorphism x y

\class Category \extends Precategory
  | Iso->eq {x y : A} : x ~= y -> x = y

-- 4.2.5
\class Groupoid \extends Precategory
  | is-Iso {x y : A} (f : mor x y) : Isomorphism x y f

-- 4.2.6
-- hPOV: this can be used as an alternative definition of groups
\func Group' : \Type => Groupoid (\Sigma)
-- TODO: define groups in the usual way, and prove the two definitions are equivalent

-- 4.2.7
\func DiscreteCategory (A : \Set) : Precategory A \cowith
  | mor x y => x = y
  | ide _ => idp
  | o p q => q *> p
  | id-left _ => idp
  | id-right => idp_*>
  | o-assoc p q r => inv (*>-assoc r q p)

-- 4.2.8
\class Functor (A B : Precategory) (\classifying F : A -> B)
  | fmap {x y : A} (f : mor x y) : mor (F x) (F y)
  | fmap-id (x : A) : fmap (ide x) = id
  | fmap-o {x y z : A} (f : mor y z) (g : mor x y) : fmap (f o g) = fmap f o fmap g

\func IdFunctor (A : Precategory) : Functor A A Function.id \cowith
  | fmap f => f
  | fmap-id _ => idp
  | fmap-o _ _ => idp

\func comp-functor {A B C : Precategory} (F : Functor B C) (G : Functor A B) : Functor A C (F.F Function.`o` G.F) \cowith {
  -- FIXME: why the classifying field of Functor doesn't work?
  | fmap f => F.fmap (G.fmap f)
  | fmap-id x => pmap F.fmap (G.fmap-id x) *> F.fmap-id _
  | fmap-o f g => pmap F.fmap (G.fmap-o f g) *> F.fmap-o _ _
}
